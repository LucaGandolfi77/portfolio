<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title data-i18n="morse.page.title">Morse Converter â€” Luca Gandolfi</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#07101b;--card:#0b1220;--accent:#00d4ff}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#07101b,#0f1724);color:#e8f6ff}
    .wrap{max-width:960px;margin:36px auto;padding:28px}
  .lang-top-left{position:fixed;top:12px;left:12px;z-index:1002}
  .drop-zone{border:1px dashed rgba(255,255,255,0.06);padding:8px;border-radius:10px;position:relative}
  .drop-zone.dragover{background:linear-gradient(180deg,rgba(0,0,0,0.08),rgba(255,255,255,0.01));border-color:var(--accent)}
  .drop-hint{position:absolute;right:10px;bottom:8px;font-size:0.85rem;color:#9fbcd8}
    .lang-top-left select{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.06);color:white;padding:6px 8px;border-radius:6px}
    a.back{color:var(--accent);text-decoration:none;font-weight:600}
    .panel{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:18px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.04)}
    textarea{width:100%;height:200px;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(0,0,0,0.15);color:inherit;resize:vertical;font-family:inherit}
    .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
    .btn{background:var(--accent);color:#002;padding:8px 12px;border-radius:8px;border:none;font-weight:700;cursor:pointer}
    .small{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.03);cursor:pointer}
    .hint{color:#9fbcd8;font-size:0.95rem;margin-top:8px}
    @media(max-width:800px){.panel{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="lang-top-left">
    <select id="langSelect" aria-label="Select language">
      <option value="en">ğŸ‡¬ğŸ‡§ EN</option>
      <option value="it">ğŸ‡®ğŸ‡¹ IT</option>
      <option value="fr">ğŸ‡«ğŸ‡· FR</option>
      <option value="es">ğŸ‡ªğŸ‡¸ ES</option>
      <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­</option>
      <option value="ru">ğŸ‡·ğŸ‡º RU</option>
      <option value="de">ğŸ‡©ğŸ‡ª DE</option>
      <option value="ja">ğŸ‡¯ğŸ‡µ æ—¥æœ¬</option>
      <option value="sv">ğŸ‡¸ğŸ‡ª SV</option>
      <option value="ar">ğŸ‡¸ğŸ‡¦ AR</option>
      <option value="he">ğŸ‡®ğŸ‡± HE</option>
    </select>
  </div>

  <div class="wrap">
    <a class="back" href="technology.html">â† <span data-i18n="page.back">Back to portfolio</span></a>
    <h1 data-i18n="morse.page.heading">Morse Converter</h1>
    <p data-i18n="morse.page.lead">Convert text to Morse code and back. Includes simple play and copy features.</p>

    <div class="panel">
      <div class="card">
        <label for="inputText" style="font-weight:700"> <span data-i18n="morse.input.label">Input</span></label>
        <div id="dropZone" class="drop-zone" title="Drop .txt files here or click to select">
          <textarea id="inputText" placeholder="Type text or paste Morse here..." aria-label="Input"></textarea>
          <div class="drop-hint" id="dropHint" data-i18n="morse.dragdrop.hint">Drop .txt here or click to import</div>
        </div>
        <div class="controls">
          <button id="toMorse" class="btn" data-i18n="morse.buttons.toMorse">Text â†’ Morse</button>
          <button id="toText" class="small" data-i18n="morse.buttons.toText">Morse â†’ Text</button>
          <button id="copyInput" class="small" data-i18n="morse.buttons.copy">Copy</button>
          <input id="importFile" type="file" accept=".txt" class="small" title="Import .txt" />
          <button id="exportInput" class="small" data-i18n="morse.buttons.export">Export input</button>
        </div>
        <div class="hint" data-i18n="morse.hint">Use dot (.) dash (-) and spaces between letters. Use " / " for word separator.</div>
      </div>

      <div class="card">
        <label for="outputText" style="font-weight:700"> <span data-i18n="morse.output.label">Output</span></label>
        <textarea id="outputText" placeholder="Result" aria-label="Output" readonly></textarea>
        <div class="controls">
          <button id="copyOutput" class="btn" data-i18n="morse.buttons.copyOutput">Copy result</button>
          <label style="display:flex;align-items:center;gap:8px;margin:0 8px"> <span data-i18n="morse.controls.wpm">WPM</span>
            <input id="wpm" type="range" min="5" max="40" value="14" style="width:120px">
            <small id="wpmVal" style="min-width:36px;text-align:center">14</small>
          </label>
          <button id="playMorse" class="small" data-i18n="morse.buttons.play">Play</button>
          <button id="clear" class="small" data-i18n="morse.buttons.clear">Clear</button>
          <button id="exportOutput" class="small" data-i18n="morse.buttons.export">Export result</button>
          <button id="exportWav" class="small" data-i18n="morse.buttons.exportAudio">Export WAV</button>
        </div>
        <div id="status" class="hint"></div>
      </div>
    </div>

  </div>

  <script>
    // Basic Morse map
    const MORSE = {
      'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.','H':'....','I':'..','J':'.---','K':'-.-','L':'.-..','M':'--','N':'-.','O':'---','P':'.--.','Q':'--.-','R':'.-.','S':'...','T':'-','U':'..-','V':'...-','W':'.--','X':'-..-','Y':'-.--','Z':'--..',
      '0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....','6':'-....','7':'--...','8':'---..','9':'----.',
      '.':'.-.-.-',',':'--..--','?':'..--..','!':'-.-.--','/':'-..-.','(':'-.--.',')':'-.--.-','&':'.-...',':':'---...',';':'-.-.-.','=':'-...-','+':'.-.-.','-':'-....-','_':'..--.-','"':'.-..-.','$':'...-..-','@':'.--.-.'
    };
    const INV = {}; Object.keys(MORSE).forEach(k=>INV[MORSE[k]] = k);

    function textToMorse(text){
      // tolerant: accept mixed input, ignore unknown chars
      return text.toUpperCase().split('').map(ch=>{
        if(ch === ' ') return '/';
        return MORSE[ch] || '';
      }).filter(Boolean).join(' ').replace(/\s+\/\s+/g,' / ');
    }

    function morseToText(morse){
      // tolerant parser: accept . - â€¢ âˆ’ and separators / or |; ignore empty tokens
      const cleaned = morse.replace(/â€¢/g,'.').replace(/âˆ’/g,'-').replace(/\|/g,'/');
      return cleaned.trim().split(/\s+/).map(token=> token === '/' ? ' ' : (INV[token]||'')).join('');
    }

    // elements
    const input = document.getElementById('inputText');
    const output = document.getElementById('outputText');
    const toMorseBtn = document.getElementById('toMorse');
    const toTextBtn = document.getElementById('toText');
    const copyInputBtn = document.getElementById('copyInput');
    const copyOutputBtn = document.getElementById('copyOutput');
    const playBtn = document.getElementById('playMorse');
    const clearBtn = document.getElementById('clear');
    const status = document.getElementById('status');

    toMorseBtn.addEventListener('click', ()=>{
      const v = input.value || '';
      const res = textToMorse(v);
      output.value = res;
      status.textContent = '';
    });
    toTextBtn.addEventListener('click', ()=>{
      const v = input.value || '';
      const res = morseToText(v);
      output.value = res;
      status.textContent = '';
    });

    copyInputBtn.addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(input.value||''); status.textContent = 'Copied input'; setTimeout(()=>status.textContent='',1500);}catch(e){status.textContent='Copy failed';}
    });
    copyOutputBtn.addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(output.value||''); status.textContent = 'Copied result'; setTimeout(()=>status.textContent='',1500);}catch(e){status.textContent='Copy failed';}
    });

    clearBtn.addEventListener('click', ()=>{ input.value=''; output.value=''; status.textContent=''; });

    // Play Morse as beeps (simple WebAudio)
    playBtn.addEventListener('click', ()=>{
      const seq = (output.value||'').trim();
      if(!seq) return; 
      const wpm = parseInt(document.getElementById('wpm').value,10) || 14;
      // dit length in seconds: 1.2 / WPM (ITU PARIS standard approx)
      const unit = 1.2 / wpm;
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      let t = ctx.currentTime + 0.02;
      function tone(time,duration){ const o = ctx.createOscillator(); const g = ctx.createGain(); o.type='sine'; o.frequency.value=700; o.connect(g); g.connect(ctx.destination); g.gain.value=0.0001; o.start(time); g.gain.linearRampToValueAtTime(0.12,time+0.005); g.gain.linearRampToValueAtTime(0.0001,time+duration); o.stop(time+duration+0.02); }
      const seqTokens = seq.replace(/â€¢/g,'.').replace(/âˆ’/g,'-').replace(/\|/g,'/').split(/\s+/);
      seqTokens.forEach(sym=>{
        if(sym === '/') { t += unit*7; return; }
        for(let ch of sym){ if(ch === '.') { tone(t, unit); t += unit*2; } else if(ch === '-') { tone(t, unit*3); t += unit*4; } }
        t += unit*2;
      });
    });

    // WPM UI update
    const wpmEl = document.getElementById('wpm');
    const wpmVal = document.getElementById('wpmVal');
    if(wpmEl && wpmVal){ wpmVal.textContent = wpmEl.value; wpmEl.addEventListener('input', ()=> wpmVal.textContent = wpmEl.value); }

    // Import/Export
    const importFile = document.getElementById('importFile');
    const exportInput = document.getElementById('exportInput');
    const exportOutput = document.getElementById('exportOutput');
    if(importFile){ importFile.addEventListener('change', (evt)=>{
      const f = evt.target.files && evt.target.files[0]; if(!f) return; const reader = new FileReader(); reader.onload = e=>{ input.value = e.target.result || ''; status.textContent = 'File loaded'; setTimeout(()=>status.textContent='',1400); }; reader.readAsText(f);
    }); }

    // Drag & Drop support for input textarea
    const dropZone = document.getElementById('dropZone');
    if(dropZone){
      // clicking the zone opens file picker (reuse existing input)
      dropZone.addEventListener('click', ()=>{ importFile && importFile.click(); });

      dropZone.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; dropZone.classList.add('dragover'); });
      dropZone.addEventListener('dragenter', (e)=>{ e.preventDefault(); dropZone.classList.add('dragover'); });
      dropZone.addEventListener('dragleave', (e)=>{ e.preventDefault(); dropZone.classList.remove('dragover'); });
      dropZone.addEventListener('drop', (e)=>{
        e.preventDefault(); dropZone.classList.remove('dragover');
        const dt = e.dataTransfer; if(!dt) return; const files = Array.from(dt.files || []);
        if(!files.length){ status.textContent = 'No file dropped'; setTimeout(()=>status.textContent='',1400); return; }
        // accept text files; read first text-like file, or concatenate if multiple
        const textFiles = files.filter(f=> f.type.startsWith('text') || f.name.toLowerCase().endsWith('.txt'));
        if(!textFiles.length){ status.textContent = 'No text file found'; setTimeout(()=>status.textContent='',1400); return; }
        const readers = textFiles.map(f=> new Promise((res,rej)=>{ const r=new FileReader(); r.onload = ev=> res(String(ev.target.result || '')); r.onerror = rej; r.readAsText(f); }));
        Promise.all(readers).then(contents=>{
          // join with double newlines between files for clarity
          input.value = contents.join('\n\n');
          status.textContent = `Loaded ${textFiles.length} file(s)`;
          setTimeout(()=>status.textContent='',1600);
        }).catch(err=>{ console.error(err); status.textContent='Failed to read dropped file'; setTimeout(()=>status.textContent='',1600); });
      });
    }
    if(exportInput){ exportInput.addEventListener('click', ()=>{ const blob = new Blob([input.value||''],{type:'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'morse-input.txt'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),2000); status.textContent='Exported'; setTimeout(()=>status.textContent='',1300); }); }
    if(exportOutput){ exportOutput.addEventListener('click', ()=>{ const blob = new Blob([output.value||''],{type:'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'morse-output.txt'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),2000); status.textContent='Exported'; setTimeout(()=>status.textContent='',1300); }); }
    // Export WAV
    const exportWavBtn = document.getElementById('exportWav');
    function generateWavFromMorse(seq, wpm, opts={sampleRate:44100, freq:700, amp:0.25}){
      const sampleRate = opts.sampleRate || 44100;
      const freq = opts.freq || 700;
      const amp = opts.amp || 0.25;
      const unit = 1.2 / (wpm || 14); // seconds per dit
      // build segments: {type:'tone'|'silence', dur: seconds}
      const tokens = seq.replace(/â€¢/g,'.').replace(/âˆ’/g,'-').replace(/\|/g,'/').trim().split(/\s+/);
      const segs = [];
      tokens.forEach((tok, ti)=>{
        if(tok === '/') { segs.push({type:'silence', dur: unit*7}); return; }
        for(let i=0;i<tok.length;i++){
          const ch = tok[i];
          if(ch === '.') segs.push({type:'tone', dur: unit});
          else if(ch === '-') segs.push({type:'tone', dur: unit*3});
          // intra-element gap (1 unit) between elements
          if(i < tok.length - 1) segs.push({type:'silence', dur: unit});
        }
        // inter-letter gap (3 units)
        segs.push({type:'silence', dur: unit*3});
      });
      // trim trailing silence
      while(segs.length && segs[segs.length-1].type === 'silence') segs.pop();

      // total samples
      const totalSec = segs.reduce((s,seg)=>s + seg.dur, 0);
      const totalSamples = Math.ceil(totalSec * sampleRate);
      const buffer = new Float32Array(totalSamples);
      let offset = 0;
      for(const seg of segs){
        const samples = Math.floor(seg.dur * sampleRate);
        if(seg.type === 'silence'){ offset += samples; continue; }
        // tone: fill sine
        for(let i=0;i<samples && offset < totalSamples;i++, offset++){
          buffer[offset] = amp * Math.sin(2*Math.PI*freq*(i/sampleRate));
        }
      }

      // convert to 16-bit PCM WAV
      function floatTo16BitPCM(float32Array){
        const buffer = new ArrayBuffer(float32Array.length * 2);
        const view = new DataView(buffer);
        let offset = 0;
        for(let i=0;i<float32Array.length;i++, offset+=2){
          let s = Math.max(-1, Math.min(1, float32Array[i]));
          view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
        return view;
      }

      const wavHeaderSize = 44;
      const pcmView = floatTo16BitPCM(buffer);
      const wavBuffer = new ArrayBuffer(wavHeaderSize + pcmView.byteLength);
      const view = new DataView(wavBuffer);
      let ptr = 0;
      function writeString(s){ for(let i=0;i<s.length;i++){ view.setUint8(ptr++, s.charCodeAt(i)); } }
      writeString('RIFF'); view.setUint32(ptr, 36 + pcmView.byteLength, true); ptr +=4; writeString('WAVE'); writeString('fmt '); view.setUint32(ptr, 16, true); ptr+=4; view.setUint16(ptr, 1, true); ptr+=2; view.setUint16(ptr, 1, true); ptr+=2; view.setUint32(ptr, sampleRate, true); ptr+=4; view.setUint32(ptr, sampleRate * 2, true); ptr+=4; view.setUint16(ptr, 2, true); ptr+=2; view.setUint16(ptr, 16, true); ptr+=2; writeString('data'); view.setUint32(ptr, pcmView.byteLength, true); ptr+=4;
      // copy pcm data
      const pcmBytes = new Uint8Array(pcmView.buffer);
      new Uint8Array(wavBuffer, wavHeaderSize).set(pcmBytes);
      return new Blob([wavBuffer], {type: 'audio/wav'});
    }

    if(exportWavBtn){ exportWavBtn.addEventListener('click', ()=>{
      const seq = (output.value||'').trim(); if(!seq){ status.textContent='Nothing to export'; setTimeout(()=>status.textContent='',1400); return; }
      const wpm = parseInt(document.getElementById('wpm').value,10) || 14;
      try{
        const blob = generateWavFromMorse(seq, wpm, {sampleRate:44100, freq:700, amp:0.25});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `morse-${Date.now()}.wav`; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),2000);
        status.textContent='WAV exported'; setTimeout(()=>status.textContent='',1300);
      }catch(e){ console.error(e); status.textContent='Export failed'; setTimeout(()=>status.textContent='',1400); }
    }); }

    // i18n loader (simple reuse)
    async function loadTranslations(lang){
      try{ const r = await fetch('/i18n/'+lang+'.json'); if(!r.ok) throw 0; return await r.json(); }catch(e){ try{ const r2 = await fetch('/i18n/en.json'); if(r2.ok) return await r2.json(); }catch(e){} return {}; }
    }
    function getNested(o,p){ return p.split('.').reduce((a,k)=> (a && a[k]!==undefined)? a[k]: undefined, o); }
    const savedLang = localStorage.getItem('lang')||'en';
    document.addEventListener('DOMContentLoaded', async ()=>{
      const t = await loadTranslations(savedLang);
      document.querySelectorAll('[data-i18n]').forEach(el=>{ const k = el.getAttribute('data-i18n'); const v = getNested(t,k); if(v!==undefined) el.textContent = v; });
      const sel = document.getElementById('langSelect'); if(sel){ sel.value = savedLang; sel.addEventListener('change', async (e)=>{ const v = e.target.value||'en'; localStorage.setItem('lang',v); const tt = await loadTranslations(v); document.querySelectorAll('[data-i18n]').forEach(el=>{ const k = el.getAttribute('data-i18n'); const vv = getNested(tt,k); if(vv!==undefined) el.textContent = vv; }); }); }
    });
  </script>
</body>
</html>
